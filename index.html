---
layout: default
title: jMonkey Wiki
---

<h2>The jME3 Threading Model</h2>

jME3 is similar to Swing in that, for speed and efficiency, all changes to the scene graph must be made in a single
update thread. If you make changes only in Control.update(), AppState.update(), or SimpleApplication.simpleUpdate(),
this will happen automatically. However, if you pass work to another thread, you may need to pass results back to the
main jME3 thread so that scene graph changes can take place there.

{% highlight java %}
public void rotateGeometry(final Geometry geo, final Quaternion rot) {
    mainApp.enqueue(new Callable<Spatial>() {
        public Spatial call() throws Exception {
            return geo.rotate(rot);
        }
    });
}
{% endhighlight %}

Note that this example does not fetch the returned value by calling <span class="snippet">get()</span> on the Future object returned from <span class="snippet">enqueue()</span>.
This means that the example method <span class="snippet">rotateGeometry()</span> will return immediately and will not wait for the rotation to be
processed before continuing.<br/>
<br/>
If the processing thread needs to wait or needs the return value then <span class="snippet">get()</span> or the other methods in the returned Future
object such as <span class="snippet">isDone()</span> can be used.<br/>

<h2>Multithreading Optimization</h2>
First, make sure you know what Application States and Custom Controls are.<br/><br/>
More complex games may feature complex mathematical operations or artificial intelligence calculations (such as path
finding for several NPCs). If you make many time-intensive calls on the same thread (in the update loop), they will
block one another, and thus slow down the game to a degree that makes it unplayable. If your game requires long
running tasks, you should run them concurrently on separate threads, which speeds up the application considerably.<br/><br/>

Often multithreading means having separate detached logical loops going on in parallel, which communicate about their
state. (For example, one thread for AI, one Sound, one Graphics). However we recommend to use a global update loop
for game logic, and do multithreading within that loop when it is appropriate. This approach scales way better to
multiple cores and does not break up your code logic.<br/><br/>

Effectively, each for-loop in the main update loop might be a chance for multithreading, if you can break it up into self-contained tasks.<br/>

<h2>Java Multithreading</h2>
The java.util.concurrent package provides a good foundation for multithreading and dividing work into tasks that can be
executed concurrently (hence the name). The three basic components are the Executor (supervises threads),
Callable Objects (the tasks), and Future Objects (the result). You can read about the concurrent package more here,
I will give just a short introduction.<br/><br/>

<ul>
    <li>A Callable is one of the classes that gets executed on a thread in the Executor. The object represents one of several concurrent tasks (e.g, one NPC's path finding task). Each Callable is started from the updateloop by calling a method named call().</li>
    <li>The Executor is one central object that manages all your Callables. Every time you schedule a Callable in the Executor, the Executor returns a Future object for it.</li>
    <li>A Future is an object that you use to check the status of an individual Callable task. The Future also gives you the return value in case one is returned.</li>
</ul>


