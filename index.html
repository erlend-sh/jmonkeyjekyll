---
layout: default
title: jMonkey Wiki
---

<h2>The jME3 Threading Model</h2>

jME3 is similar to Swing in that, for speed and efficiency, all changes to the scene graph must be made in a single
update thread. If you make changes only in Control.update(), AppState.update(), or SimpleApplication.simpleUpdate(),
this will happen automatically. However, if you pass work to another thread, you may need to pass results back to the
main jME3 thread so that scene graph changes can take place there.

{% highlight java %}
public void rotateGeometry(final Geometry geo, final Quaternion rot) {
    mainApp.enqueue(new Callable<Spatial>() {
        public Spatial call() throws Exception {
            return geo.rotate(rot);
        }
    });
}
{% endhighlight %}

Note that this example does not fetch the returned value by calling <span class="snippet">get()</span> on the Future object returned from <span class="snippet">enqueue()</span>.
This means that the example method <span class="snippet">rotateGeometry()</span> will return immediately and will not wait for the rotation to be
processed before continuing.<br/>
<br/>
If the processing thread needs to wait or needs the return value then <span class="snippet">get()</span> or the other methods in the returned Future
object such as <span class="snippet">isDone()</span> can be used.

<h2>Multithreading Optimization</h2>
First, make sure you know what Application States and Custom Controls are.<br/><br/>
More complex games may feature complex mathematical operations or artificial intelligence calculations (such as path
finding for several NPCs). If you make many time-intensive calls on the same thread (in the update loop), they will
block one another, and thus slow down the game to a degree that makes it unplayable. If your game requires long
running tasks, you should run them concurrently on separate threads, which speeds up the application considerably.<br/><br/>

Often multithreading means having separate detached logical loops going on in parallel, which communicate about their
state. (For example, one thread for AI, one Sound, one Graphics). However we recommend to use a global update loop
for game logic, and do multithreading within that loop when it is appropriate. This approach scales way better to
multiple cores and does not break up your code logic.<br/><br/>

Effectively, each for-loop in the main update loop might be a chance for multithreading, if you can break it up into self-contained tasks.